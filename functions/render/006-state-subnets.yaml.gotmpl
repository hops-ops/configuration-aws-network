# code: language=yaml
#
# Build subnet state from spec + $observed
# Mode detection, VPC CIDR abstraction, and subnet list building with cidrmath
# Depends on: 000-004 ($observed), 005-state-spec (all $_* variables)
#
# Convention: All intermediate variables use $_ prefix
# Only $state and $observed are available to resource templates
#

# ==============================================================================
# Mode Detection
# ==============================================================================
# IPAM mode: VPC CIDR comes from IPAM pool allocation
{{ $_ipamMode := $_ipv4IpamEnabled }}
# Manual mode: VPC CIDR is explicitly specified
{{ $_manualMode := and (not $_ipamMode) (ne $_vpcCidrSpec "") }}
# Layout mode: using subnetLayout to auto-calculate subnets (works with both IPAM and manual)
{{ $_layoutMode := or $_ipamMode (and $_manualMode (gt (len $_layoutAzs) 0) (eq (len $_subnetsSpec) 0)) }}

# Enable ULA flag when using IPAM allocation (for IPv6 detection)
{{ if $_ipv6UlaIpamEnabled }}
  {{ $_ulaEnabled = true }}
{{ end }}

# IPv6 flags
{{ $_hasIpv6 := or $_ulaEnabled $_amazonIpv6Enabled $_ipv6UlaIpamEnabled }}

# ==============================================================================
# VPC CIDR - Abstracted Source
# The key insight: downstream templates don't care where the CIDR comes from
# ==============================================================================
{{ $_vpcCidr := "" }}
{{ if $_manualMode }}
  {{ $_vpcCidr = $_vpcCidrSpec }}
{{ else }}
  # In IPAM mode, use observed CIDR (may be empty until VPC is created)
  {{ $_vpcCidr = $observed.vpc.cidr }}
{{ end }}

# IPv6 VPC CIDR (from observed, regardless of source)
{{ $_vpcIpv6Cidr := $observed.vpc.ipv6Cidr }}

# ==============================================================================
# Build Subnet Lists
# ==============================================================================
{{ $_publicSubnets := list }}
{{ $_privateSubnets := list }}
{{ $_availabilityZones := list }}

# ------------------------------------------------------------------------------
# Manual Mode with explicit subnets: Build from spec.subnets[]
# ------------------------------------------------------------------------------
{{ if and $_manualMode (not $_layoutMode) }}
  {{ $_azSet := dict }}

  {{ range $_subnet := $_subnetsSpec }}
    {{ $_subnetName := $_subnet.name | default "" }}
    {{ $_subnetExternalName := $_subnet.externalName | default "" }}
    {{ $_subnetManagementPolicies := $_subnet.managementPolicies | default $_managementPolicies }}
    {{ $_subnetCidr := $_subnet.cidr | default "" }}
    {{ $_subnetAz := $_subnet.availabilityZone | default "" }}
    {{ $_isPublic := $_subnet.public | default false }}
    {{ $_subnetIpv6 := $_subnet.ipv6 | default (dict) }}
    {{ $_subnetUlaCidr := $_subnetIpv6.ulaCidr | default "" }}
    {{ $_subnetAmazonCidr := $_subnetIpv6.amazonProvidedCidr | default "" }}

    # Normalize AZ to suffix only
    {{ $_azSuffix := $_subnetAz }}
    {{ if hasPrefix $_awsRegion $_subnetAz }}
      {{ $_azSuffix = trimPrefix $_awsRegion $_subnetAz }}
    {{ end }}
    {{ $_fullAz := printf "%s%s" $_awsRegion $_azSuffix }}

    # Track unique AZs
    {{ if not (hasKey $_azSet $_azSuffix) }}
      {{ $_ := set $_azSet $_azSuffix true }}
      {{ $_availabilityZones = append $_availabilityZones $_azSuffix }}
    {{ end }}

    # Build tags
    {{ $_tier := "private" }}
    {{ $_mapPublicIp := false }}
    {{ $_k8sRoleTag := "kubernetes.io/role/internal-elb" }}
    {{ if $_isPublic }}
      {{ $_tier = "public" }}
      {{ $_mapPublicIp = true }}
      {{ $_k8sRoleTag = "kubernetes.io/role/elb" }}
    {{ end }}

    {{ $_subnetTags := merge (dict) $_awsTags (dict
      "Name" $_subnetName
      "hops.ops.com.ai/tier" $_tier
      "hops.ops.com.ai/az" $_azSuffix
      $_k8sRoleTag "1"
    ) }}

    {{ $_config := dict
      "name" $_subnetName
      "externalName" $_subnetExternalName
      "managementPolicies" $_subnetManagementPolicies
      "resourceName" (printf "subnet-%s" $_subnetName)
      "cidr" $_subnetCidr
      "az" $_fullAz
      "azSuffix" $_azSuffix
      "public" $_isPublic
      "mapPublicIpOnLaunch" $_mapPublicIp
      "tags" $_subnetTags
      "labels" (dict "hops.ops.com.ai/network" $_networkName "hops.ops.com.ai/tier" $_tier "hops.ops.com.ai/az" $_azSuffix)
      "ipv6UlaCidr" $_subnetUlaCidr
      "ipv6AmazonCidr" $_subnetAmazonCidr
    }}

    {{ if $_isPublic }}
      {{ $_publicSubnets = append $_publicSubnets $_config }}
    {{ else }}
      {{ $_privateSubnets = append $_privateSubnets $_config }}
    {{ end }}
  {{ end }}

  {{ $_availabilityZones = $_availabilityZones | sortAlpha }}
{{ end }}

# ------------------------------------------------------------------------------
# Layout Mode: Calculate subnet CIDRs from VPC CIDR
# Works with both IPAM and manual VPC CIDR
# Uses manual CIDR calculation since ipam subnet pools isn't available
# programatically yet
# ------------------------------------------------------------------------------
{{ if $_layoutMode }}
  {{ $_availabilityZones = $_layoutAzs | sortAlpha }}
  {{ $_numAzs := len $_availabilityZones }}

  # Only calculate subnets if we have a VPC CIDR
  {{ if ne $_vpcCidr "" }}
    # Parse VPC CIDR: "10.0.0.0/16" -> octets [10, 0, 0, 0] and prefix 16
    {{ $_vpcParts := splitList "/" $_vpcCidr }}
    {{ $_vpcIp := index $_vpcParts 0 }}
    {{ $_vpcPrefix := 16 }}
    {{ if gt (len $_vpcParts) 1 }}
      {{ $_vpcPrefix = index $_vpcParts 1 | int }}
    {{ end }}

    {{ $_octets := splitList "." $_vpcIp }}
    {{ $_octet1 := index $_octets 0 }}
    {{ $_octet2 := index $_octets 1 }}

    # For /16 VPC with /24 public and /20 private:
    # - Public /24: {o1}.{o2}.{index}.0/24 (256 IPs each)
    # - Private /20: {o1}.{o2}.{16 + index*16}.0/20 (4096 IPs each, starts at .16.0)
    #
    # Layout: |--public /24s (0-15)--|--private /20s (16+)--|

    {{ $_azIndex := 0 }}
    {{ range $_az := $_availabilityZones }}
      {{ $_fullAz := printf "%s%s" $_awsRegion $_az }}

      # Public subnet - /24 starting from .0.0
      {{ if $_layoutPublicEnabled }}
        {{ $_publicThirdOctet := $_azIndex }}
        {{ $_publicCidr := printf "%s.%s.%d.0/%d" $_octet1 $_octet2 $_publicThirdOctet $_layoutPublicNetmask }}
        {{ $_subnetName := printf "%s-public-%s" $_networkName $_az }}

        # Calculate IPv6 subnet for public - only Amazon-provided (not ULA)
        # ULA is private addressing and should not be on public subnets
        # For /56 VPC like fda0:daf7:1:100::/56, subnets modify the 4th group:
        #   - Subnet 0: fda0:daf7:1:100::/64
        #   - Subnet 1: fda0:daf7:1:101::/64
        {{ $_ipv6AmazonCidr := "" }}
        {{ if and $_amazonIpv6Enabled (ne $_vpcIpv6Cidr "") }}
          {{ $_ipv6Parts := splitList "/" $_vpcIpv6Cidr }}
          {{ $_ipv6Base := index $_ipv6Parts 0 }}
          {{ $_ipv6Groups := splitList ":" (trimSuffix "::" $_ipv6Base) }}
          {{ $_numGroups := len $_ipv6Groups }}
          {{ $_g1 := index $_ipv6Groups 0 }}
          {{ $_g2 := "" }}{{ if ge $_numGroups 2 }}{{ $_g2 = index $_ipv6Groups 1 }}{{ end }}
          {{ $_g3 := "" }}{{ if ge $_numGroups 3 }}{{ $_g3 = index $_ipv6Groups 2 }}{{ end }}
          {{ $_g4 := "" }}{{ if ge $_numGroups 4 }}{{ $_g4 = index $_ipv6Groups 3 }}{{ end }}
          # Extract base of 4th group (all but last 2 chars) and append subnet index as 2-digit hex
          {{ $_g4Len := len $_g4 }}
          {{ $_g4Base := "" }}
          {{ if gt $_g4Len 2 }}
            {{ $_g4Base = substr 0 (sub $_g4Len 2 | int) $_g4 }}
          {{ end }}
          # Use 2-digit hex when g4Base exists (to preserve subnet portion width), single digit otherwise
          {{ $_subnetHex := "" }}
          {{ if ne $_g4Base "" }}
            {{ $_subnetHex = printf "%02x" $_azIndex }}
          {{ else }}
            {{ $_subnetHex = printf "%x" $_azIndex }}
          {{ end }}
          {{ $_newG4 := printf "%s%s" $_g4Base $_subnetHex }}
          {{ $_ipv6AmazonCidr = printf "%s:%s:%s:%s::/64" $_g1 $_g2 $_g3 $_newG4 }}
        {{ end }}

        {{ $_subnetTags := merge (dict) $_awsTags (dict
          "Name" $_subnetName
          "hops.ops.com.ai/tier" "public"
          "hops.ops.com.ai/az" $_az
          "kubernetes.io/role/elb" "1"
        ) }}

        # Compute final IPv6 values for this subnet
        {{ $_ipv6CidrBlock := $_ipv6AmazonCidr }}
        {{ $_assignIpv6 := ne $_ipv6CidrBlock "" }}

        # Get externalName from layout map (key = "public-{az}")
        {{ $_subnetKey := printf "public-%s" $_az }}
        {{ $_subnetExternalName := get $_layoutExternalNames $_subnetKey | default "" }}

        {{ $_config := dict
          "name" $_subnetName
          "externalName" $_subnetExternalName
          "managementPolicies" $_layoutManagementPolicies
          "resourceName" (printf "subnet-public-%s" $_az)
          "cidr" $_publicCidr
          "az" $_fullAz
          "azSuffix" $_az
          "public" true
          "mapPublicIpOnLaunch" true
          "tags" $_subnetTags
          "labels" (dict "hops.ops.com.ai/network" $_networkName "hops.ops.com.ai/tier" "public" "hops.ops.com.ai/az" $_az)
          "ipv6CidrBlock" $_ipv6CidrBlock
          "assignIpv6AddressOnCreation" $_assignIpv6
        }}

        {{ $_publicSubnets = append $_publicSubnets $_config }}
      {{ end }}

      # Private subnet - /20 starting from .16.0 (skips first /20 block used by public /24s)
      {{ if $_layoutPrivateEnabled }}
        # Each /20 is 16 third-octets (e.g., .16.0-.31.255, .32.0-.47.255, etc.)
        {{ $_privateThirdOctet := mul (add $_azIndex 1) 16 }}
        {{ $_privateCidr := printf "%s.%s.%d.0/%d" $_octet1 $_octet2 $_privateThirdOctet $_layoutPrivateNetmask }}
        {{ $_subnetName := printf "%s-private-%s" $_networkName $_az }}

        # Calculate IPv6 subnets for private - supports both ULA and Amazon-provided
        # For /56 VPC like fda0:daf7:1:100::/56, subnets modify the 4th group:
        #   - Subnet 0: fda0:daf7:1:100::/64
        #   - Subnet 1: fda0:daf7:1:101::/64
        # The last 2 hex digits of the 4th group encode the subnet index
        {{ $_ipv6UlaCidr := "" }}
        {{ $_ipv6AmazonCidr := "" }}
        {{ if ne $_vpcIpv6Cidr "" }}
          {{ $_ipv6Parts := splitList "/" $_vpcIpv6Cidr }}
          {{ $_ipv6Base := index $_ipv6Parts 0 }}
          {{ $_ipv6Groups := splitList ":" (trimSuffix "::" $_ipv6Base) }}
          {{ $_numGroups := len $_ipv6Groups }}
          {{ $_g1 := index $_ipv6Groups 0 }}
          {{ $_g2 := "" }}{{ if ge $_numGroups 2 }}{{ $_g2 = index $_ipv6Groups 1 }}{{ end }}
          {{ $_g3 := "" }}{{ if ge $_numGroups 3 }}{{ $_g3 = index $_ipv6Groups 2 }}{{ end }}
          {{ $_g4 := "" }}{{ if ge $_numGroups 4 }}{{ $_g4 = index $_ipv6Groups 3 }}{{ end }}
          # Extract base of 4th group (all but last 2 chars) and append subnet index as 2-digit hex
          {{ $_g4Len := len $_g4 }}
          {{ $_g4Base := "" }}
          {{ if gt $_g4Len 2 }}
            {{ $_g4Base = substr 0 (sub $_g4Len 2 | int) $_g4 }}
          {{ end }}
          # ULA IPv6 for private subnets (sequential from 0)
          {{ if or $_ulaEnabled $_ipv6UlaIpamEnabled }}
            # Use 2-digit hex when g4Base exists (to preserve subnet portion width), single digit otherwise
            {{ $_subnetHex := "" }}
            {{ if ne $_g4Base "" }}
              {{ $_subnetHex = printf "%02x" $_azIndex }}
            {{ else }}
              {{ $_subnetHex = printf "%x" $_azIndex }}
            {{ end }}
            {{ $_newG4 := printf "%s%s" $_g4Base $_subnetHex }}
            {{ $_ipv6UlaCidr = printf "%s:%s:%s:%s::/64" $_g1 $_g2 $_g3 $_newG4 }}
          {{ end }}
          # Amazon-provided IPv6 for private subnets (offset after public subnets)
          {{ if $_amazonIpv6Enabled }}
            {{ $_ipv6PrivateIndex := add $_azIndex $_numAzs }}
            # Use 2-digit hex when g4Base exists (to preserve subnet portion width), single digit otherwise
            {{ $_subnetHex := "" }}
            {{ if ne $_g4Base "" }}
              {{ $_subnetHex = printf "%02x" $_ipv6PrivateIndex }}
            {{ else }}
              {{ $_subnetHex = printf "%x" $_ipv6PrivateIndex }}
            {{ end }}
            {{ $_newG4 := printf "%s%s" $_g4Base $_subnetHex }}
            {{ $_ipv6AmazonCidr = printf "%s:%s:%s:%s::/64" $_g1 $_g2 $_g3 $_newG4 }}
          {{ end }}
        {{ end }}

        {{ $_subnetTags := merge (dict) $_awsTags (dict
          "Name" $_subnetName
          "hops.ops.com.ai/tier" "private"
          "hops.ops.com.ai/az" $_az
          "kubernetes.io/role/internal-elb" "1"
        ) }}

        # Compute final IPv6 values for this subnet (ULA preferred over Amazon-provided)
        {{ $_ipv6CidrBlock := $_ipv6UlaCidr | default $_ipv6AmazonCidr }}
        {{ $_assignIpv6 := ne $_ipv6CidrBlock "" }}

        # Get externalName from layout map (key = "private-{az}")
        {{ $_subnetKey := printf "private-%s" $_az }}
        {{ $_subnetExternalName := get $_layoutExternalNames $_subnetKey | default "" }}

        {{ $_config := dict
          "name" $_subnetName
          "externalName" $_subnetExternalName
          "managementPolicies" $_layoutManagementPolicies
          "resourceName" (printf "subnet-private-%s" $_az)
          "cidr" $_privateCidr
          "az" $_fullAz
          "azSuffix" $_az
          "public" false
          "mapPublicIpOnLaunch" false
          "tags" $_subnetTags
          "labels" (dict "hops.ops.com.ai/network" $_networkName "hops.ops.com.ai/tier" "private" "hops.ops.com.ai/az" $_az)
          "ipv6CidrBlock" $_ipv6CidrBlock
          "assignIpv6AddressOnCreation" $_assignIpv6
        }}

        {{ $_privateSubnets = append $_privateSubnets $_config }}
      {{ end }}

      {{ $_azIndex = add $_azIndex 1 }}
    {{ end }}
  {{ end }}
{{ end }}

# ==============================================================================
# Derived Flags (from subnet lists)
# ==============================================================================
{{ $_hasPublicSubnets := gt (len $_publicSubnets) 0 }}
{{ $_hasPrivateSubnets := gt (len $_privateSubnets) 0 }}
