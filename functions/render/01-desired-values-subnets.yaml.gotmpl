# code: language=yaml

# Process explicit subnet array from spec
{{ $subnetsSpec := $spec.subnets | default (list) }}

# Build subnet configs with computed values
{{ $publicSubnets := list }}
{{ $privateSubnets := list }}
{{ $availabilityZones := list }}
{{ $azSet := dict }}

{{ range $subnet := $subnetsSpec }}
  {{ $subnetName := $subnet.name | default "" }}
  {{ $subnetCidr := $subnet.cidr | default "" }}
  {{ $subnetAz := $subnet.availabilityZone | default "" }}
  {{ $isPublic := $subnet.public | default false }}
  {{ $subnetIpv6 := $subnet.ipv6 | default (dict) }}
  {{ $subnetUlaCidr := $subnetIpv6.ulaCidr | default "" }}
  {{ $subnetAmazonCidr := $subnetIpv6.amazonProvidedCidr | default "" }}

  # Normalize AZ to suffix only (strip region prefix if present)
  {{ $azSuffix := $subnetAz }}
  {{ if hasPrefix $awsRegion $subnetAz }}
    {{ $azSuffix = trimPrefix $awsRegion $subnetAz }}
  {{ end }}

  # Full AZ name
  {{ $fullAz := printf "%s%s" $awsRegion $azSuffix }}

  # Track unique AZs
  {{ if not (hasKey $azSet $azSuffix) }}
    {{ $_ := set $azSet $azSuffix true }}
    {{ $availabilityZones = append $availabilityZones $azSuffix }}
  {{ end }}

  # Resource name for annotations (sanitized)
  {{ $resourceName := printf "subnet-%s" $subnetName }}

  # Build tags
  {{ $tier := "private" }}
  {{ $mapPublicIp := false }}
  {{ $k8sRoleTag := "kubernetes.io/role/internal-elb" }}
  {{ if $isPublic }}
    {{ $tier = "public" }}
    {{ $mapPublicIp = true }}
    {{ $k8sRoleTag = "kubernetes.io/role/elb" }}
  {{ end }}

  {{ $subnetTags := merge (dict) $awsTags (dict
    "Name" $subnetName
    "hops.ops.com.ai/tier" $tier
    "hops.ops.com.ai/az" $azSuffix
    $k8sRoleTag "1"
  ) }}

  {{ $subnetConfig := dict
    "name" $subnetName
    "resourceName" $resourceName
    "cidr" $subnetCidr
    "az" $fullAz
    "azSuffix" $azSuffix
    "public" $isPublic
    "mapPublicIpOnLaunch" $mapPublicIp
    "tags" $subnetTags
    "labels" (dict "hops.ops.com.ai/network" $networkName "hops.ops.com.ai/tier" $tier "hops.ops.com.ai/az" $azSuffix)
    "ipv6UlaCidr" $subnetUlaCidr
    "ipv6AmazonCidr" $subnetAmazonCidr
  }}

  {{ if $isPublic }}
    {{ $publicSubnets = append $publicSubnets $subnetConfig }}
  {{ else }}
    {{ $privateSubnets = append $privateSubnets $subnetConfig }}
  {{ end }}
{{ end }}

# Sort availability zones
{{ $availabilityZones = $availabilityZones | sortAlpha }}

# Derived flags
{{ $hasPublicSubnets := gt (len $publicSubnets) 0 }}
{{ $hasPrivateSubnets := gt (len $privateSubnets) 0 }}

# NAT Gateway configuration
{{ $natDesired := and $natEnabled $hasPublicSubnets $hasPrivateSubnets (ne $natStrategyUpper "NONE") }}
{{ $singleNatSuffix := "" }}
{{ if gt (len $availabilityZones) 0 }}
  {{ $singleNatSuffix = index $availabilityZones 0 }}
{{ end }}

# Build NAT configs
{{ $natConfigsForCreation := list }}
{{ $natConfigsByAz := dict }}

{{ if $natDesired }}
  {{ range $subnet := $publicSubnets }}
    {{ $azSuffix := $subnet.azSuffix }}

    # Determine if this AZ needs a NAT
    {{ $needsNat := false }}
    {{ if eq $natStrategyUpper "HIGHLYAVAILABLE" }}
      {{ $needsNat = true }}
    {{ else if eq $natStrategyUpper "SINGLEAZ" }}
      {{ $needsNat = eq $azSuffix $singleNatSuffix }}
    {{ end }}

    {{ if and $needsNat (not (hasKey $natConfigsByAz $azSuffix)) }}
      {{ $natName := printf "%s-nat-%s" $networkName $azSuffix }}
      {{ $natConfig := dict
        "name" $natName
        "resourceName" (printf "nat-%s" $azSuffix)
        "eipName" (printf "%s-nat-eip-%s" $networkName $azSuffix)
        "eipResourceName" (printf "eip-%s" $azSuffix)
        "publicSubnet" $subnet.name
        "publicSubnetResourceName" $subnet.resourceName
        "azSuffix" $azSuffix
      }}
      {{ $natConfigsForCreation = append $natConfigsForCreation $natConfig }}
      {{ $_ := set $natConfigsByAz $azSuffix $natConfig }}
    {{ end }}
  {{ end }}
{{ end }}

# Build private route table configs (one per AZ with private subnets)
{{ $privateRouteTables := list }}
{{ $privateRtByAz := dict }}

{{ range $subnet := $privateSubnets }}
  {{ $azSuffix := $subnet.azSuffix }}
  {{ if not (hasKey $privateRtByAz $azSuffix) }}
    {{ $rtName := printf "%s-private-rt-%s" $networkName $azSuffix }}
    {{ $rtConfig := dict
      "name" $rtName
      "resourceName" (printf "rt-private-%s" $azSuffix)
      "azSuffix" $azSuffix
    }}
    {{ $privateRouteTables = append $privateRouteTables $rtConfig }}
    {{ $_ := set $privateRtByAz $azSuffix $rtConfig }}
  {{ end }}
{{ end }}

# Map NAT gateways to private route tables
{{ range $i, $rt := $privateRouteTables }}
  {{ $azSuffix := $rt.azSuffix }}
  {{ $targetNatAz := $azSuffix }}
  {{ if eq $natStrategyUpper "SINGLEAZ" }}
    {{ $targetNatAz = $singleNatSuffix }}
  {{ end }}
  {{ $natConfig := get $natConfigsByAz $targetNatAz }}
  {{ if $natConfig }}
    {{ $_ := set $rt "natGateway" $natConfig }}
  {{ end }}
{{ end }}

# Update derived flags
{{ $renderNatGateways := and $natDesired (gt (len $natConfigsForCreation) 0) }}
{{ $renderInternetGateway := $hasPublicSubnets }}
{{ $renderEgressOnlyIgw := and $hasIpv6 $hasPrivateSubnets }}
{{ $renderFlowLogs := and $flowLogsEnabled $flowLogsDestinationArn }}
